# Accuknox eBPF Assignment Solutions

This repository contains my solutions for the Accuknox eBPF assignment, covering three problem statements.

---

## Problem 1: Drop TCP Packets on a Configurable Port

**Objective:**  
Write an eBPF program to drop TCP packets on a specific port, defaulting to 4040. The port number should be configurable from user space.

**Solution Overview:**  
- Implemented an XDP eBPF program that inspects incoming packets, checking if they are TCP packets targeting the specified port.  
- The port to be dropped is stored in a BPF map, allowing runtime updates from the user space program.  
- Packets matching the TCP destination port are dropped, others are passed normally.  
- A drop counter map tracks the number of dropped packets.

**Key Files:**  
- `Problem1/drop_tcp.c` — The eBPF XDP program source code.  
- `Problem1/main.go` — Go user space loader that loads the eBPF program, updates the port map, and attaches the program to a network interface.

**How to Build & Run:**  
1. Compile eBPF program:
    ```
    clang -O2 -target bpf -c drop_tcp.c -o drop_tcp.o
    ```
2. Build Go loader:
    ```
    go build -o main main.go
    ```
3. Run loader with sudo (specify interface and port if needed):  
    ```
    sudo ./main --iface eth0 --port 4040
    ```

---

## Problem 2: Drop Packets Only for a Given Process

**Objective:**  
Write an eBPF program that allows traffic only on TCP port 4040 for a specific process (e.g., "myprocess") and drops all other ports for that process.

**Solution Overview:**  
- Implemented an eBPF program attached via a cgroup sockops or cgroup/connect4 hook (depending on environment).  
- The program checks the current process name against the target process and allows traffic only on the specified port for that process.  
- All other traffic for that process is dropped. Other processes are not affected.  
- A BPF map stores allowed process IDs or names.

**Key Files:**  
- `Problem2/main.go` — Go program to load and manage the eBPF cgroup filter, set allowed process, and manage cgroup memberships.  
- `Problem2/filter.c` (if applicable) — eBPF cgroup program source code.

**How to Use:**  
1. Compile and load the eBPF program via the Go loader.  
2. Move desired process PID into the cgroup specified.  
3. The program filters traffic at the cgroup level based on process and port.

---

## Problem 3: Explanation of Go Concurrency Code Snippet

**Objective:**  
Explain a Go code snippet that creates a buffered channel of functions and multiple goroutines processing those functions.

**Explanation Summary:**  
- `make(chan func(), 10)` creates a buffered channel that can hold up to 10 functions. It acts as a queue for tasks.  
- The `for` loop with 4 iterations spawns 4 goroutines (workers), each reading from the channel and executing received functions.  
- The function sent to the channel prints "HERE1", but it does not appear in output because the main function exits immediately after sending the function and printing "Hello", before the goroutines run the function.  
- To fix this, synchronizing goroutines with the main function (using `sync.WaitGroup`, closing the channel, or adding a sleep) is necessary to let goroutines finish execution.

**Snippet Location:**  
- Captured in `problem3.md` or included as a documented markdown explanation.

---

## Additional Notes

- The solutions use modern CO-RE eBPF practices relying on `vmlinux.h` generated by `bpftool` for kernel awareness.  
- User-space programs use the `github.com/cilium/ebpf` Go library for interacting with eBPF maps and loading programs.  
- Testing was done using local loopback, virtual interfaces, and netcat for TCP connectivity tests.

---

Feel free to reach out if you want detailed build instructions or code walkthroughs for any of the problems.
